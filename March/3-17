图灵机  冯诺依曼结构
二进制：0101
位 bit 用于流量b
字节 Byte 8bit 用于存储单位 B
字 word 4B 8B W
CPU 控制单元CU+算术逻辑单元ALU
总线 bus（汇流排）
RAM cache 内存 速度快成本高断电丢失
外部存储 磁带磁盘光盘硬盘usb固态硬盘

计算机语言  人与计算机之间通讯的语言
机器语言：二进制序列 指令+数据
汇编语言：符号代替二进制 汇编器
高级语言：类似人 编译 面向过程/对象
标准语法ANSI C

特点：简洁紧凑灵活方便  运算符丰富  数据类型丰富  表达方式灵活实用  允许直接访问物理地址对硬件操作  生成目标代码质量高程序执行率高  可移植性好
操作系统开发
嵌入式开发
C++Java有参照c  基础语言：解释器实现

精神：信任程序员 不妨碍程序员做需要做的事 语言精炼 一种方法执行一项操作  程序运行更快即使不能保证可移植性
编译器：GCC Visual C++    环境：Vim  Dev c++   Visual Studio Code+Cygwin
编程program 编译compile 调试debug

7个步骤（无序）  ： 定义程序目标 设计程序 编写代码 编译 运行 测试调试 维护修改
边做边改 瀑布 快速原型 增量 螺旋 演化 喷泉
数据：计算机处理符号集合  数据结构：具有结构的数据元素集合
结构分类： 逻辑结构  存储结构  静态结构  动态结构
算法：解决特定问题的指令的集合  有限的基本步骤  解决问题的办法
算法+数据结构=程序  算法本质：根据处理问题需要，在数据逻辑结构和存储结构基础上施加的一种运算  输入输出有穷性确定性有效性
基本算法：穷举 归纳 回溯 模拟
算法分析：目的：评价效率 判定优劣 改进算法
	复杂度：时间 空间 数量级 时空矛盾
时间复杂度：因素：问题规模 编译功能强弱 机器代码质量优劣 执行一条指令时间长短 程序中语句执行次数   频度：语句 算法
O(log2n)<O(n)<O(nlog2n)<O(n2)<O(n3)<o(2^n)
分析：循环 考虑最坏情况

空间复杂度：存储空间：本身占用 输入输出 临时占用
流程图：起止框 判断框 处理框 输入/输出框 注释框 流向线 连接点
1.表示相应操作的框 2.带箭头的流程线 3.文字说明
顺序结构 选择结构（While Until） 循环结构
编码 0-1 字符 数字

明解C
源程序：通过字符序列创建  （源文件）  .c
注释在/* 和 */之间
printf函数输出
；构成完整语句
8个翻译阶段 编译器 解释方式 
%d 实参显示  转换说明   \n换行
字符串常量：双引号括起来的一连串连续排列的文字
\a响铃
变量  声明时可用，分隔
scanf从键盘中读入 &i 表示存取
puts函数顺序输出实参字符串，结尾换行  与printf \n 功能基本相同
运算符 操作数   第一操作数 第二操作数
printf打印%  %%来打印 类似于\\     puts不具有转换说明功能
正%正--->正   负%负--->取决于编译器（其他几种都取决于编译器）
单目运算符  正负
数据类型：int整数 范围-32767-32767（编译器不同）  double双精度浮点数%f 默认小数点后6位
double类型通过scanf赋值时要用%lf
%取余不能用于浮点数间运算
操作数类型不同时，较小的数据类型操作数会转换为较大类型，int转为double
（double）a    类型转换
%5d 5位十进制   %5.1f  5位浮点数（小数点后只显示1位）
%09.9f   
用0补齐位数  %-4d  左对齐  
精度整数时默认1，浮点数默认6 
转换说明符
if（表达式）语句    如果表达式不为0执行相应语句
if（表达式）语句   else 语句
相等运算符 ==  对左右操作数比较  相等则结果为1 不相等则为0  结果是int     ！=
比较余数vx%10 ==5
关系运算符  （比大小得到整数int 1或者0）
三个分支：if    else if     else
嵌套的if
条件运算符（三目运算符）  a?b:c   a不为0，则结果为b 否则为c
复合语句（程序块）{ }下并排书写，中间可以写声明，但要放在最前面
逻辑运算符 &&  a&&b都不为0 则结果为1 否则结果为0    ||逻辑运算符 或
多分支使用 switch （）{case -: break    default:}    由括号内结果判断是哪个情况，碰见break跳出语句
如果没有别的情形，则执行default
if switch 统称选择语句

do while    do语句   只要控制表达式结果不是0  循环体语句循环执行
仅在复合语句中使用的变量通常要在复合语句中声明
！逻辑非  用来判断操作数是否为0     !a  当a的值为0时值为1，a不为0时值为0
创建对象（变量）同时为其指定初始值   称为可初始化    声明变量时除非有特别要求，一定要进行初始化
后置递增运算/后置递减运算符     a++    即a=a+1
while 语句  while（表达式）语句
字符常量  ‘ ’单引号括起来的字符称为字符常量  putchar('')可以用来显示字符 只有一个参数
printf i--   先显示i的值，再进行i--
数据递增
限定次数循环操作
前置递增，前置递减   ++a   先自增，然后处理/显示
for语句  for(i=0;i<=100;i++)   for(a;b;c)  先处理a  循环控制b重复执行，循环体执行后执行c
a仅在循环前执行一次，可以省略
b如果省略，除非有break否则无限循环
c可以省略，最后执行
do/while/for 循环语句
多重循环
关键字 auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while
标识符 非数字开头，区分大小写（尽量不使用_开头的标识符）
分隔符 []{}()*,:=;...#
运算符  常量 字符串常量
构成语句的单位中间不能插入空格
预处理指令中间不能换行
长字符串常量可以通过双引号及注释分隔开
四位缩进

数组
int vc[5]  数组对象  相同类型对象的集合   元素个数必须是常量
int vc[5] = {1, 2, 3, 4, 5}
不能通过赋值语句初始化，不能超过数组下标
不能直接vb = va 互相赋值，而是各个元素逐一赋值
额外变量temp实现交换 
#define NUMBER  5     宏  使用宏便于统一管理，增强阅读性
不能 int a=b=0同时声明两个变量，而需要分开声明
多维数组 
二维数组  数组名[下标][下标]
不足时自动补0，声明方式{{}，{}}，也可以直接{}
质数，大整数  unsigned long类型  %lu
break语句跳出循环
1.判断质数，两层循环能否整除，能则break，然后打印
2.利用偶数必然不是质数直接+2
3.利用奇数不会被偶数整除，内循环加2
4.无法被小于整数的质数整除，则是质数
5.无法被小于等于整数的平方根的质数整除
逗号运算符 a，b 顺次对ab计算，把b的结果作为整个表达式的值

main函数  库函数
函数头 形式参数
使用函数 即调用函数  函数调用表达式：函数名 实参
函数体被大括号{}括起的复合语句
return语句 
对函数调用表达式进行判定时，会得到该返回类型的返回值
实参，形参名字可相同
函数内声明变量不能与形参同名
值传递（通过值进行参数传递）  灵活运用值传递可以使函数简洁紧凑
没有返回值的函数类型要声明为void
可以将函数返回值作为变量初始值
赋予变量的标识符 名称有一个通用的范围称为作用域   块作用域  文件作用域（从头到尾通用）
函数原型声明，以分号结尾
非定义声明：没有真正创建出变量的实体
一般把main放在最后 把被调用函数放在调用函数前
头文件<stdio.h>，#include指令称为文件包含指令
从通用性考虑，应该可以处理任意数组，不同元素个数的数组
被调用函数中作为形参接收到的数组就是函数调用时被作为实参的数组
const类型修饰符 避免传递给函数的数组内容发生改变
顺序查找
哨兵查找 数组末尾追加的数据称为哨兵，简化对循环结束条件判断
空语句 表达式语句
声明接受多维数组形参时，可以省略第一维元素个数
两个同名变量拥有文件作用域和块作用域，那么只有拥有块作用域的变量是可见的，拥有文件作用域的变量会被隐藏
存储期，变量的生存期   存储类说明符static
自动存储期，不使用static定义出的对象，被赋予了自动存储空间，执行到对象声明时就创建了相应对象，执行到程序块结尾对象消失     编译器赋予不确定的值
静态存储期，使用static定义出的对象，程序执行前准备阶段创建出来，程序结束时消失，‘永久’寿命
register声明，保存在寄存器，现在已基本不使用

int double 算术类型   整数类 浮点型 
枚举型 字符型 整型
10进制，二进制，八进制，十六进制
二进制：偶数末位为0，奇数末位为1       余数逆向排列（除2)
无符号整型，有符号整型
char    short int     int      long int
补码使编译器多表示1个负数
limits.h头文件 
char保存字符型
sizeof运算符，通过使用sizeof可以判断包括char型在内的所有数据类型长度
size_t型，typedef声明定义size_t         typedef unsigned size_t
整型常量数据类型后面的后缀 U L
在int范围内就是int 否则在long范围内就是long 除此之外都是unsigned long
内部表示和位  位：具有大量内存空间的运行环境的数据存储单元 可保存两种取值对象，对象中各二进制位地址不需要表示
二进制补码，最高位（符号位）为0，表示非负数
补码与反码   正数部分位串相同，负数最高位是1
补码表示32个整数，反码表示31个整数
反码：逐位求反  补码：逐位取反后加1
按位与运算符：&运算符
按位或运算符：|运算符
按位异或运算符：^运算符   （两个条件只有1个为真）
~运算符：按位求反运算符
逻辑运算符与按位逻辑运算符
位移运算符 <<  >> 求初左移或右移整数中的位之后的值，这两个运算符统称为位移运算符
a<<b 将a左移b位，右面空出位用0填充
右移（有符号）有可能逻辑位移，有可能算数位移
不对负数做位移
逻辑位移不考虑符号位，所有二进制都做位移
算术位移保留最高位符号，右移1位，值变1/2
printf  八进制用%o  十六进制用%x 或%X   字母大小写
数据溢出会发生异常   无符号整数类型会返回除以1与该数据类型可表示最大值的和之后所得余数
浮点型  float  double  long double
尾数，指数，尾数小数部分决定精度，指数的位数决定长度
浮点型后缀  f或F表示float
循环判断基准所用变量应为整数而不用浮点数
math.h 头文件  sqrt计算平方根
运算
优先级   结合性
整型提升 不改变符号和数值
浮点型与整数类
有符号整型和无符号整型
浮点型
普通算数类型转换（双目运算符）

函数式宏
#define sqr(x)((x)*(x))
如果x++则有可能执行两次  副作用
sqr  (x)((x)*(x))有空格就是对象式宏 sqr会被替代   为防止优先级问题 都用括号括起来
逗号运算符代替；从而展开后避免错误     如果要代换两个以上的表达式 则使用逗号运算符连接
enum枚举类型  枚举常量 没有给定值为前一值加1  多个枚举常量允许具有相同值
命名空间  枚举名和变量名分别属于不同命名空间
递归  阶乘注意有可能超出范围    调用了与自身相同的函数
输入输出和字符
EOF end of file   定义为-1
getchar（）   可移植性
'0' 与 0 不同

字符串
\0 null字符
字符串字面量
字符串以字符数组实现   %s    char str[4]="ABC"
字符串读取没带&
%9.9s 宽度 精度 转换符  9 至少显示 .9 至多显示 -左对齐 否则右对齐 
二维数组表示字符串数组  初始值不足时用\0填充
传入字符串不能带&  二维也是线性排列
二维只有第一维数组元素数可以省略
toupper转换为大写  tolower转换为小写

指针
值传递  指针  对象  地址
取址运算符 & 取得地址/生成指针  可以输出地址 用%p
int 和 *int   保存整数的盒子   保存 存放整数对象地址的 盒子      指向
*a  代表a指向的对象  a代表指向的地址  *a代表别名
对*a赋值等同于将地址内的值改变
形参怎么修改都只是临时性复制 指针是直接改变值  函数传入指针则直接修改指针指向的值
两值互换    
C++引用传递  提高主调函数和被调函数的联系  降低了模块独立性  c语言不支持
定义函数时使用对象*    调用函数时使用地址&
scanf函数接受的是指针
指针是指向“以OO号为首地址的XX型对象”
register声明的寄存器对象不能加上&
数值型和指针型统称标量型
指针指向数组   *(ptr+i)  等价于 ptr[i]  等价于a[i]
不带下标运算符单独出现的数组名会被视为指向该数组的第一个元素的指针
超越数组范围无法保证指向数组后内存空间
函数形参如果是数组，则等价于指针，可以修改实参

字符串与指针
指针实现字符串  
操作字符串字面量时，数据类型指向char型变量的指针，指向该字符串字面量的第一个字符
相同点：可以使用下标运算符表示字符串中任意字符
数组实现的字符串 不能再赋值为其它字符串
数组元素在连续内存单元中保存，指针实现的字符串不会占用太多内存空间
指针一维字符串等于二位字符串数组    都可以使用下标        不同点在于 指针不会有多余空间，但会多存放指针本身
数据类型前加上const，该指针指向值不能修改   常用于函数定义
指针自增，表示指向下一个对象
提高效率，无需使用循环变量
有的编译器无法改写字符串字面量  还可能会写入非空内存空间（影响其他值）
strlen返回字符串长度   strcpy复制后一个字符串到前一个，返回前一个字符串    strncpy加了一个长度控制，若大于n则到n为止
strcat 连接字符串    strncat 加上n控制长度     strcmp比较两个字符串大小关系，若相等返回0，大于返回正整数       strncmp加n控制长度
atoi将字符串指针转换为int     atol即将字符串转换为long  atof转换为double

结构体
冒泡排序   交换排序算法 较轻的气泡会不断往上冒
插入排序  选择排序  冒泡排序
卡片形式的数据结构 通过结构体实现       结构体是聚合了一系列数据的数据结构    一个框架
对象名.成员名   未赋初始值元素被初始化为0
(*std).height  优先级问题，必须有括号    使用->可以将其简写为std->height
a->b    指针访问结构体a中成员b
聚合类型  元素类型  可否赋值    用于操作不同类型数据的集合   数组不可直接赋值，结构体可以赋值
命名空间  标签名  小标签名  成员名  一般性标识符     不同命名空间可以使用相同名字
结构体数组
派生类型   数组类型 结构体类型 共用体类型 函数类型 指针类型
表示日期和时间的结构体     time函数用于获取当前日期和时间   1970年1.1上午至今秒数
localtime将其转换为日常生活形式

文件处理
文件  流   printf scanf都使用了流
标准流  stdin标准输入  stdout输出   stderr错误
FILE型   文件位置指针符 记录当前访问地址     错误指示符  记录是否发生了读取/写入错误   我文件结束指示符 记录是否已到达文件末尾
fopen函数用来打开文件    fclose关闭
fscanf函数从文件读取数据  加入了输入流
写入日期和时间   fprintf函数  加入了输出流
获取上一次运行时的信息
显示文件内容  fgetc函数 增加了输入流         fputc函数写 putchar
如果不想丢数据，就要写入所有位数
文本文件字符数取决于数值位数     二进制文件字符数不依赖数值位数
二进制  fwrite函数  fread函数  用于写入和读取
显示文件自身    isprint函数判断是否是字符
