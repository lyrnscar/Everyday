树    人类社会家谱 社会组织结构 图书信息管理    层次关系
分层次组织在管理上具有更高效率  插入删除查找   查找  有效率查找
给定某个关键字k，从集合R中找出关键字与k相同记录
静态查找  集合中记录固定 没有插入和删除 只有查找     动态查找 集合记录动态变化 除了查找还可能发生插入/删除
静态查找  顺序查找 哨兵查找 时间复杂度为n

二分查找   假设有序 连续存放  则可进行二分查找
left>right查找失败    对数时间复杂度 logn
判定树  每个结点查找次数为该节点所在层数   查找成功时次数不会超过深度   深度为log2n +1   

树 n个结点构成有限集合
n=0时为空树   任一非空树  树中有一个根节点r表示  其余分为m个互不相交的有限集  每个集合本身又是一棵树称为原来树的子树
子树不相交  每个结点有且仅有一个父节点   一颗n结点树有n-1条边
度  结点子树个数       树的度 所有节点最大度数     叶节点 度为0      父节点 有子树的结点    子节点    兄弟结点 
路径和路径长度  祖先结点  子孙结点  结点的层次    树的深度（层次数）

树的表示  
儿子-兄弟表示法    第一个儿子 第二个下一个兄弟
二叉树  度为2   
一个有穷的结点集合  集合可以为空   若不为空 则它是由根结点和称为其左子树和右子树的两个不相交的二叉树
有五种基本形态  空树 一个结点  左  右  左右     二叉树有左右之分
斜二叉树（链表）       完美二叉树/满二叉树         完全二叉树（顺序位置与满二叉树相同）但是可以少结点
二叉树性质  第i层最大节点数为2^i-1          深度为k的二叉树最大结点总数为2^k  -1          任何非空二叉树n0=n2+1
类型名称   二叉树   数据对象集   一个有穷结点集合      操作集   isempty    crwatbintree创建     traversal遍历 先序根左右  中序左根右    后序左右根    层次 从上到下从左到右

二叉树的存储结构  顺序存储结构  完全二叉树 从上至下从左到右 n个结点的结点父子关系   非根结点父结点序号是i/2     结点左孩子2i  若2i<=n 否则没有左孩子    同理右孩子2i+1
链表存储结构    treenode 三个部分左指针 数据 右指针

二叉树遍历  先序遍历  访问根结点 先序遍历左子树 先序遍历右子树 递归      
中序遍历   中序遍历左子树  访问根结点  中序遍历右子树
后序遍历   后序遍历左子树  后序遍历右子树   访问根结点
路径一致 访问各结点时机不同
递归基础（堆栈）

中序遍历非递归遍历算法   基本思路 使用堆栈
遇到一个结点 压栈 遍历左子树   左子树遍历结束后 栈顶弹出访问    按右指针中序遍历右子树

层序遍历  二叉树遍历核心问题  二维结构线性化  从结点访问左右儿子结点  访问左儿子后考虑右儿子   需要存储结构保存暂时不访问的结点  存储结构 堆栈/队列
队列实现  根结点开始 根结点入队 执行循环  结点出队 访问该结点  左右儿子入队       实现了层序遍历

输出二叉树叶子节点 加个判断条件 有无儿子       
求二叉树高度 max左右+1  通过后序遍历          
二元运算表达式树及其遍历 先序得到前缀表达式  中序遍历得到中缀表达式  后序遍历得到后缀表达式
中缀表达式存在优先级问题  可以通过加括号解决
有两种遍历序列确定二叉树  必须要有中序遍历
先序和中序确定一颗二叉树   根据先序遍历序列第一个结点确定根结点    根据根结点再中序遍历序列中分割出左右两个子序列     对左子树和右子树分别递归使用相同方法继续分解

给定两棵树 如通过左右孩子互换若干次可以相互变换 则同构
输入两颗二叉树 判断是否同构
二叉树表示   建二叉树   同构判断
静态链表  结构数组表示 指向左儿子右儿子下标    没有指向它的就是根
建二叉树1 建二叉树2 判别是否同构并输出
逻辑完整
