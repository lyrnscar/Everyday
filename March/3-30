页面置换算法
功能  缺页中断发生时需要调入新页面 内存已满 选择内存中哪个物理页面被置换       尽可能减少页面换进换出次数 把未来不再使用的或短期较少使用的页面换出 在局部性原理指导下依据过去的统计数据预测
页面锁定 描述必须常驻内存的操作系统的关键部分或时间关键应用进程   页表中添加锁定标志位
最优页面置换算法  缺页中断发生时 保存在内存中的每一个逻辑页面 计算在它的下次访问之前 还需等待时间 选择时间最长的那个作为被置换页面
这是理想情况 操作系统无从得知每个页面等待多长时间才会再次访问
可作为其他算法性能评价依据

先进先出算法
选择在内存中驻留时间最长的页面并淘汰    系统维护链表 记录所有内存中的逻辑页面 从链表排列顺序来看链首驻留时间最长 发生缺页中断时把链首淘汰      性能较差 调出界面可能是经常访问的页面 Belady现象 很少单独使用
实现简单 缺页中断次数比较多

最近最久未使用算法 LRU
缺页中断发生时 选择最久未使用的那个页面
近似最优页面置换算法 依据程序局部性原理  最近一小段时间内如果某些页面被频繁访问 将来一小段时间内 他们还可能会再一次频繁访问 反之亦然
两种可能实现方法   系统维护一个页面链表 最近刚使用页面作为首结点 最久作为尾 每次发生缺页中断淘汰链表末尾页面         
设置一个活动页面栈 访问某页时将页号压入栈顶 考察栈内是否有与此页面相同页号 有则抽出 如需淘汰页面 选择栈底页面

时钟页面置换算法 clock
LRU近似 对FIFO的一种改进   需要用到页表访问位 如果被访问置1  各个页面组织呈环形链表 指针指向最老页面 发生缺页中断考察指向最老页面 若访问位为0淘汰 若1置0向下移动1格至找到被淘汰页面

二次机会法   enhance clock
时钟页面 巨大代价替换'脏'页   修改clock算法 使它允许脏页总在一次时钟头扫描中保留下来
同时使用脏位和使用位指导置换    写操作

最不常用法LFU
当缺页中断发生时 选择访问次数最少的页面淘汰      实现方法 对每个页面设置一个访问计数器 每当一个页面被访问 该页面访问计数器加1 发生缺页中断时淘汰计数值最小的页面
LRU考虑的是多久未访问 LFU考察的是访问次数
可以定期把次数寄存器右移一位

Belady现象
采用FIFO时 有时会出现分配的物理页面数增加 缺页率反而提高的异常现象
FIFO算法的置换特征与进程访问内存的动态特征是矛盾的 与置换算法目标不一致 因此被它置换出去的页面并不一定是进程不会访问的
LRU算法没有这一现象 栈算法 满足物理页帧越多缺页次数越少
LRU/FIFO本质都是先进先出 LRU针对页面最近访问时间进行排序   clock是对LRU的近似
局部性  LRU开销较大 clock开销较小效果较好

全局页面置换算法
工作集模型  局部性原理是否成立
如果不成立 各种页面置换算法没有什么区别  如果成立如何证明存在 定量分析
工作集 一个进程当前正在使用的逻辑页面集合称为工作集    用二元函数W(t,Δ)表示
工作集碎局部性区域位置改变 扩张/收缩
常驻集 当前时刻进程实际驻留在内存当中的页面集合
窗口
取决于是否在工作集窗口之内
缺页率页面置换算法  可变分配策略 常驻集大小可变   每个进程在刚运行时先根据程序大小分配一定物理页面 进程运行过程中动态调整常驻集大小
全局页面置换 发生缺页中断时被置换页面可以是其他进程中 各个并发进程竞争使用物理页面    优缺点 性能较好 增加了系统开销      具体实现 缺页率算法PFF动态调整常驻集大小
缺页率 缺页次数/内存访问次数      页面置换算法 物理页面数目 页面本身大小 程序编写方法
缺页率过高 增加工作集   过低减少工作集  把整体缺页率控制在合理范围内
在缺页中断时进行判断
多个程序下 全局好于局部

抖动问题  
物理页面太少 不能包含整个工作集 进程将会导致很多缺页中断 需要频繁在内外存间替换界面 从而使进程运行速度变得很慢 这种状态称为抖动
驻留内存的进程数目增加 分配给每个进程的物理页面数不断减小 缺页率不断上升 os要选择适当进程数目和进程需要帧数 以便在并发水平和缺页率之间达到平衡
本地的页面置换改善
