调度
上下文切换 切换cpu的当前任务 保存当前进程/线程在pcb/tcb中执行上下文 读取下一个进程/线程上下文
cpu调度 从就绪队列中挑选一个进程/线程作为cpu将要运行的下一个线程/进程 调度程序 挑选进程/线程内核函数 何时
时间  就绪-运行-等待
内核运行调度程序条件  一个进程从运行状态切换到等待状态 一个进程被终结了
不可抢占  调度程序必须等事件结束
可以抢占  调度程序在中断被响应后执行 当前的进程从运行切换到就绪 或一个进程从等待切换到就绪   当前运行的进程可以被换出

调度原则
执行模型 程序在cpu突发和i/o中交替   每个调度决定都是关于在下一个cpu突发时将哪个工作交给cpu   在时间分片机制下 县城可能在结束当前cpu突发前被迫放弃cpu
cpu使用率 吞吐量 周转时间 等待时间 响应时间
cpu使用率 cpu处于忙状态所占时间百分比
吞吐量 单位时间完成进程数量
周转时间 一个进程从初始化到结束 包括所有等待时间花费的时间
等待时间 进程在就绪队列中总时间
响应时间 从一个请求被提交到产生第一次响应所花费的总时间
人们通常需要更快的服务  高带宽 低延迟
减少响应时间  减少平均响应时间的波动    增加吞吐量 减少开销 资源高效利用     减少等待时间
低延迟调度增加了交互式表现  操作系统需要保证吞吐量不受影响  吞吐量是操作系统的计算带宽  响应时间是操作系统的计算延迟
公平  通常会增加平均响应时间

调度算法
FCFS先来先服务
SPN SRT短进程优先 短剩余时间优先
HRRN 最高响应比优先
Round Robin 轮循
Multilevel Feedback Queues 多级反馈队列
Fair Share Scheduling 公平共享调度

FIFO队列的规定 如果进程在执行中阻塞 队列中的下一个会得到CPU     简单  缺点：平均等待时间波动较大 花费时间少的任务可能排在花费时间长的任务后面 可能导致i/o和cpu之间的重叠处理
短任务优先 选择下一个最短的进程  按照预测的完成时间来将任务入队     可抢占 叫最短剩余时间         平均等待时间最小      可能导致饥饿 连续短任务流会使长任务饥饿 短任务可用时的任何长任务的cpu时间都会增加平均等待时间     需要预知未来 怎么预估下一个cpu突发持续时间 询问用户 用户不知道完蛋
最高响应比优先 在spn调度基础上改进 不可抢占 关注进程等待了多长时间 防止无限期推迟  
轮循调度 量子的离散单元中分配处理器 时间片结束时切换到下一个准备好的进程     花销：额外的上下文切换  时间量子太大 等待时间过长 极限时退化成fcfs  时间量子太小 反应迅速 吞吐量由于大量的上下文切换开销受到影响    目标 选择合适量子 维持上下文切换开销处于1%内    公平 平均等待时间交叉
多级队列 前台交互 后台批处理   每个队列有自己的调度策略   调度必须在队列间进行 固定优先级 时间切片     进程可以在不同队列中移动   等待时间越长优先级越高       cpu密集型任务优先级下降很快   i/o密集型任务停留在高优先级    和SPN类似
FFS控制用户对系统资源访问 一些用户可能比其他用户更重要 不重要的组无法垄断资源 未使用资源按每个组所分配的资源的比例来分配 没有达到资源使用率目标的组获得更高的优先级  公平是第一要素
确定性模型 队列模型 实现/模拟

实时调度
正确性依赖于时间和功能两方面的一种操作系统    性能指标 时间约束的及时性 速度和平均性能相对不重要       时间约束的可预测性
强实时系统  需要在保证的时间内完成重要的任务    弱实时系统 要求重要的进程优先级更高 尽量完成而非必须
任务 一次计算 一次文件读取 一次信息传递     属性 取得进展所需要的资源 定时参数
一系列相似的任务 周期    任务有规律重复
硬时限 如果错过了最后时限 可能会完蛋 保证正确性   软时限 理想情况下满足 满足不得则降低要求 尽最大努力保证
表示实时系统是否能满足deadline 决定实时任务执行的顺序 静态优先级调度 动态优先级调度
RM 速率单调调度    最佳静态优先级调度 周期安排优先级 周期越短优先级越高 执行周期最短的任务
RDF最早期先调度    最佳动态优先级调度 deadline越早优先级越高  执行deadline最早的任务

多处理器调度 优先级反转
多处理器的cpu调度更复杂  多个相同的单处理器组成一个多处理器  优点 负载共享
对称多处理器SMP  每个处理器运行自己的调度程序 需要在调度程序中同步
优先级反转  在任何基于优先级的可抢占的调度机制中 系统环境强制使高优先级任务等待低优先级任务发生
低优先级任务继承高优先级任务的优先级依赖于他们共享的资源
优先级天花板 资源优先级和所有可以锁定该资源的任务中优先级最高的那个任务优先级相同   除非优先级高于系统中所有被锁定的资源优先级上限 否则任务尝试执行临界区的时候会被阻塞  持有最高优先级上限信号量锁的任务会继承被该锁阻塞任务的优先级


多道程序设计  现代操作系统重要特性  并行  进程/线程  CPU调度  调度算法
独立的线程 不和其他线程共享资源状态 确定性 可重现 调度顺序不重要     合作线程 多个线程中共享状态 不确定性 不可重现      不确定性和不可重现意味着bug可能间歇发生
进程/线程 计算机/设备需要合作   共享资源  加速  模块化
程序调用fork()来创建一个新进程  
无论多个线程指令序列怎样交替执行 程序都必须正常工作     多线程程序具有不确定性和不可重现特点  不经过专门设计 调试难度很高
不确定性要求并行程序的正确性   先思考清楚问题 把程序的行为设计清楚  不要急于写代码然后调试

race congdition竞态条件
原子操作 一次不存在任何中断或者失败的执行    实际操作往往不是原子的
单条机器指令可能都不是原子的
critical section临界区 进程中一段需要访问共享资源并且当另一个进程处于响应代码区域时不会被执行的代码区域
mutual exclusion互斥 进程处于临界区访问共享资源时没有其他进程会处于临界区访问任何相同的共享资源
dead lock死锁 两个或以上的进程在相互等待完成特定任务而最终没法将自身任务进行下去
starvation饥饿 一个可执行进程被调度器持续忽略 虽然可执行状态却不被执行

锁 解锁 死锁
为便签增加标签 
临界区
互斥    progress 前进最终会成功     有限等待     (可选)无忙等待 进入前被挂起

禁用硬件中断
没有中断 没有上下文切换 因此没有并发    硬件将中断处理延迟到中断被启用之后 大多数现代计算机体系结构都提供指令来完成
进入临界区 禁用中断
离开临界区 开启中断
一旦中断被禁用 线程就无法停止  整个系统都会停下来 可能导致其他线程饥饿
临界区可以任意长 则无法限制响应中断所需的时间（可能有硬件影响）
要小心使用

基于软件的解决方案
基于软件的解决方法 使用两个共享的数据项 turn表示谁进入临界区  flag[]指示进程是否准备好进入临界区
Bakery算法 n个进程临界区 进入临界区前接受一个数字  得到数字最小的进入临界区  如果进程pipj收到相同数字如果i<j pi先进入   编号方案总是按照枚举的增加顺序生成数字
Dekker双线程  复杂 两个进程的共享数据项  需要忙等待   需要由硬件保证 load store操作需要是原子操作

锁是一个抽象的数据结构  二进制状态 两种方法 acquire release
使用锁编写临界区
原子操作指令  特殊的内存访问电路  单处理器和多处理器
test and set 测试和置位   从内存中读取值 测试该值是否为1 内存值设置为1
交换     交换内存中两个值
使用忙等待的锁 项test-and-set的锁一样   线程在等待的时候消耗cpu周期
缺点 忙等待消耗处理器时间 进程离开临界区并且多个进程在等待时可能导致饥饿 死锁
互斥可以使用锁来实现
通常需要一定等级硬件支持
有忙等待 无忙等待


信号量
抽象数据类型 整型sem 两个原子操作  P sem减1如果小于0 等待 否则继续    V sem加1 如果sem小于等于0 唤醒一个等待的p
信号量是整数 mutex
信号量是被保护的变量 初始化完成后唯一改变值的方法是通过P V    操作必须是原子
P能够阻塞 V不会阻塞
假定信号量公平   没有线程阻塞在P仍然堵塞 如果V被无限频繁调用    实践中FIFO经常使用
两种类型 二进制0/1 一般/计数信号量 两者相互表现（给定一个实现另一个）
信号量用在两个方面 互斥 条件同步
一个线程等待另一个线程处理事情 生产or消费  互斥是不够的
正确性要求 任何一个时间只能有一个线程操作缓冲区 缓冲区空 消费者必须等待生产者    缓存区满 生产者必须等待消费者
互斥 调度 同步约束
二进制信号量用于互斥  fullbuffers  emptybuffers
生产者deposit  消费者remove

实现 
使用硬件原语 禁用中断 原子指令     类似锁
等待队列 
信号量 互斥/条件同步 等待条件是独立的互斥
读/开发代码比较困难  程序员必须非常精通
容易出错 使用的信号量已经被另一个线程占用  忘记释放信号量
不能处理死锁问题

管程 monitor
目的 分离互斥和条件同步的关注
管程 一个锁指定临界区     0或者多个条件变量 等待/通知信号量用于管理并发访问共享数据
一般方法 收集在对象/模块中的相关共享数据  定义方法访问共享数据
wait signal
lock     acquire release
variable 允许等待状态进入临界区     wait()释放锁 睡眠 重新获得锁返回后   signal()如果有则唤醒等待者
需要维持每个条件队列   线程等待的条件等待signal
lock count notfull notempty
deposit  remove
hansen/hoare两种方式 唤醒机制
开发/调试很难  同步结构

读-写者问题 哲学家就餐问题
共享数据访问 读者不修改 写者读取/修改数据  同时多个读者 任何时候只有一个写者 没有写者读者才能访问 没有读者写者才能访问  任何时候只有一个线程可以操作共享变量
哲学家就餐问题 5个哲学家坐圆 5个叉子进餐 思考放回 就餐需要两个 怎样保证哲学家动作有序进行


死锁
问题 模型 特征 处理    预防 避免 检测 恢复
一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源
可重复使用的资源 一个时间只能一个进程使用且不能被删除  进程获得资源后来释放由其他进程重用  处理器i/o通道主副存储器  设备和数据结构  文件/数据库/信号量    每个进程拥有并请求其他资源可能发生死锁
使用资源  创建/销毁  i/o缓冲区中断信号消息信息  接收消息阻塞可能会发生死锁  可能少见的组合事件会死锁
资源分配图  p进程 r资源 有向图
如果没有循环 则没有死锁
如果有循环 一个资源只有一个实例则死锁 每个资源类有几个实例 可能死锁
特征  互斥  持有并等待  无抢占  循环等待        这些是必要条件

方法
约束由强到弱
确保系统不会死锁
运行进入死锁然后恢复
忽略死锁假装没发生过 用于大多数操作系统包括unix
判断及处理消耗较大

死锁预防  
限制申请 打破条件   
互斥 共享资源非必须  必须占用非共享资源
占用并等待 必须保证当一个进程请求的资源它不吃有任何其他资源     仅当进程没有资源允许请求资源/执行之前 资源利用率低
无抢占  如果有某些资源并请求其它不能立即分配资源 则释放占有资源     被抢占资源添加到资源列表     只有当它能获得旧资源及请求的新资源 进程可以执行
循环等待 对资源类型排序 要求每个进程按顺序进行申请

死锁避免
需要系统具有一些额外的先验信息提供  进程声明可能需要的资源最大数目  分配状态通过通过限定提供/分配资源数量和进程的最大需求     死锁避免算法动态检查的资源分配状态确保永远不会环形等待
当一个进程请求资源 系统判断分配是否使系统处于安全状态
安全状态：针对所有进程 存在安全序列
序列1-n是安全的 每个pi要求的资源能够由当前可用的资源+所有的pj持有的资源来满足 其中j<i

银行家算法 dijkstra
多个实例 最大限度利用资源 请求资源不得不等待 有限时间释放
n进程数量 m资源类型数量 max总需求n*m矩阵 available剩余空闲量长为m向量  allocation已分配量n*m举证 need未来需要量n*m矩阵
work和finish是长度为m和n的向量
safe则分配 unsafe不分配

死锁检测
允许系统进入死锁状态 死锁检测算法 恢复机制
开销过大 o(m*n^2)
时间 频率

死锁恢复
终止所有死锁过程  在一个时间内终止一个进程直到死锁消除  终止进程的顺序应该是 优先级 时间 占用资源 还需资源 终止数量 交互/批处理
选择一个受害者 - 最小成本
回滚 - 返回安全状态
饥饿 - 同一进程可能一直受害

IPC 进程间通信
信号 管道 消息队列 共享内存
保护进程地址空间  进程通信机制同步  不使用共享变量的进程通信
send receive
p q 通信需要通信链路 通过send receive交换消息
链路的实现 物理 逻辑
直接通信 send receive   正确命名
间接通信 定向从消息队列接收消息  send receive目的是队列
消息传递可以是 阻塞或非阻塞的   阻断被认为是同步的 非阻断被认为是异步的
队列的消息被附加到链路  三种方式  0容量  有限容量  无限容量

signal信号 软件中断 通知信息 接收到信号时 catch指定信号处理函数调用 ignore默认操作 mask闭塞信号不会传送    不能传输交换的任何数据
管道 数据交换  shell 子进程从父进程继承文件描述符   进程不关心输入/输出的方式 buffer
消息队列 FIFO管理消息 message 一个字节序列存储 消息数组
共享内存 每个进程都有私有地址空间 每个地址空间明确设置共享内存段   快速方便共享数据 同步数据访问
即时通信


文件系统
虚拟文件系统 数据块 数据结构 分配 空闲空间列表 多磁盘管理 RAID 磁盘调度
文件系统和文件 描述符 目录 别名 系统种类
文件系统 用于持久性存储的系统抽象  文件 文件系统中一个单元的相关数据在操作系统中的抽象
分配文件磁盘空间   文件块 空闲空间 分配算法
管理文件集合   定位 命名 最常见 文件系统类型
提供便利及特征 保护 可靠性 持久性
文件基本属性 文件头
文件描述符   使用前打开 后关闭  内核跟踪每个进程打开的文件   文件指针 打开计数 磁盘位置 访问权限
用户视图 持久的数据结构   系统访问接口 字节集合 系统不关心    操作系统内部 块集合 块大小 映射
用户访问  顺序访问 随机访问 基于内容访问     无结构 简单记录结构 复杂结构     多用户/客户如何同时访问共享文件 UFS语义 会话语义 锁
目录  文件以目录方式组织起来 目录是特殊文件 目录和文件树型结构 层次名称空间     搜索 创建 删除 枚举 重命名 遍历路径   只允许内核模式修改目录
文件名的线性列表 包含指向数据块指针  编程简单执行耗时
Hash表 减少目录搜索时间 碰撞 固定大小
名字解析 逻辑名字转换成物理资源的过程
文件系统需要先挂载才能被访问  未挂载文件系统被挂载在挂载点上
文件别名   多个名字一个文件  硬链接 软链接    存储真实文件的逻辑名称来实现
删除   软链接悬空指针     硬链接backpointers 菊花链管理
如何保证无循环  只允许到文件的链接 每增加新链接都用循环检测算法确定是否合理  限制目录数量
文件系统种类  FAT NTFS     磁盘文件系统 数据库文件系统 日志文件系统 网络/分布式文件系统 特殊/虚拟文件系统
分布式 可以通过网络共享  用户辨别复杂 安全性 一致性 错误处理模式

虚拟文件系统
分层结构 上层 虚拟文件系统  底层 特定文件系统模块
目的 对所有不同文件系统的抽象   提供相同文件和文件系统接口 管理所有文件和文件系统关联的数据结构 高校查询例程遍历文件系统 与特定文件系统模块的交互
卷控制块 文件控制块 目录节点
持续存储在二级存储中   需要时加载进内存     层次结构

数据块缓存
内存中放一块缓存 databuffer 提高速度
按需读入 使用后缓存 磁盘块/页缓存
分页要求 需要一个页时载入内存 一个页可以被映射到一个本地文件中
文件数据块的页缓存  虚拟内存中文件数据快被映射成页 读/写操作被转换成对内存的访问 可能导致缺页/脏页 页置换-从进程或文件页缓存中

数据结构
打开文件描述  打开文件表
锁   一些操作系统和文件系统提供功能 调节对文件的访问 强制/劝告

文件分配
大多数文件很小 一些文件非常大
分配方式 连续分配 链式分配 索引分配
指标 高效 存储利用    表现 访问速度
连续分配     分配策略 最先匹配 最佳匹配    文件读取表现好 高效顺序随机访问   碎片 文件增长 预分配/按需分配
链式分配     链表方式     创建 增大 缩小很容易 没有碎片      不可能真正随机访问  可靠性
索引分配     索引数据块 指针列表        创建 增大 缩小很容易 没有碎片 支持直接访问        文件很小 开销相对较大  大文件处理    链式索引块 多级索引块     提高文件大小限制阈值 动态分配数据块 小文件开销小 只为大文件分配间接数据块
空闲空间管理  跟踪在存储中所有未分配的数据块 空闲空间列表存储 最佳数据结构
位图代表空闲数据块列表  指向空闲列表的指针  链式列表 分组列表

多磁盘管理 
通常磁盘通过分区最大限度减少寻道时间   一个分区时柱面集合 每个分区是逻辑上独立的磁盘
分区 硬件磁盘的一种适合操作系统指定格式的划分  卷 一个拥有一个文件系统实例的可访问的存储空间
使用多个并行磁盘 吞吐量 可靠性 可用性 
RAID冗余磁盘阵列   提高访问效率
实现在操作系统内核 存储/卷管理
数据块分成多个子块存储在独立磁盘   通过更大的有效块大小提供更大的磁盘带宽
可靠性 读取性能增加  
奇偶校验磁盘 parity
单位 块 0 4 5      raid3 bit
RAID-5每个条带块带有一个奇偶校验块 允许一个磁盘错误
RAID-6两个冗余块 特殊编码方式 允许两个磁盘错误

磁盘调度
旋转寻道 移动 磁头读取
读取或写入时 磁头定位在期望磁道    寻道时间  旋转延迟
寻道时间是性能上区别的原因 对单个磁盘会有一个i/o请求数目 如果请求随机则表现很差
按顺序处理 公平对待所有进程 很多进程时接近随即调度
最短服务优先 从磁臂当前位置需要移动最少的i/o 总选择最短寻道时间
scan电梯   磁臂在一个方向上移动 满足所有未完成请求 直到磁臂到达该方向上最后磁道 调换方向 电梯算法
优化     c-scan     限制仅在一个方向上扫描 最后一个磁道也被访问后 磁臂返回到磁盘另一端再扫描   先低序再高序
再优化  c-look 磁臂先到达该方向上最后一个请求处 再向回访问
磁臂黏着 来回小范围移动
n-step-scan算法减缓该现象 
FSCAN 简化 2步2个队列 高效 公平 均匀 降低开销
